[{"title":"[C++] 백준 1004번 : 어린 왕자","date":"2023-03-06","desc":"수학, 기하학","category":"PS","slug":"boj-1004","thumbnail":null,"body":"## 문제\n\n어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.  \n\n![문제이미지](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201003/dfcmhrjj_113gw6bcng2_b.gif)\n\n빨간 실선은 어린 왕자가 출발점에서 도착점까지 도달하는데 있어서 필요한 행성계 진입/이탈 횟수를 최소화하는 경로이며, 원은 행성계의 경계를 의미한다. 이러한 경로는 여러 개 존재할 수 있지만 적어도 3번의 행성계 진입/이탈이 필요하다는 것을 알 수 있다.  \n위와 같은 은하수 지도, 출발점, 도착점이 주어졌을 때 어린 왕자에게 필요한 최소의 행성계 진입/이탈 횟수를 구하는 프로그램을 작성해 보자. 행성계의 경계가 맞닿거나 서로 교차하는 경우는 없다. 또한, 출발점이나 도착점이 행성계 경계에 걸쳐진 경우 역시 입력으로 주어지지 않는다.  \n\n## 입력\n\n입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 첫째 줄에 출발점 (x1, y1)과 도착점 (x2, y2)이 주어진다. 두 번째 줄에는 행성계의 개수 n이 주어지며, 세 번째 줄부터 n줄에 걸쳐 행성계의 중점과 반지름 (cx, cy, r)이 주어진다.\n\n## 출력\n\n각 테스트 케이스에 대해 어린 왕자가 거쳐야 할 최소의 행성계 진입/이탈 횟수를 출력한다.\n\n## 제한\n\n-   -1000 ≤ x1, y1, x2, y2, cx, cy ≤ 1000\n-   1 ≤ r ≤ 1000\n-   1 ≤ n ≤ 50\n-   좌표와 반지름은 모두 정수\n\n## 예제\n\n### 예제 입력 1\n```\n2\n-5 1 12 1\n7\n1 1 8\n-3 -1 1\n2 2 2\n5 5 1\n-4 5 1\n12 1 1\n12 1 2\n-5 1 5 1\n1\n0 0 2\n```\n\n### 예제 출력 1\n```\n3\n0\n```\n\n### 예제 입력 2\n```\n3\n-5 1 5 1\n3\n0 0 2\n-6 1 2\n6 2 2\n2 3 13 2\n8\n-3 -1 1\n2 2 3\n2 3 1\n0 1 7\n-4 5 1\n12 1 1\n12 1 2\n12 1 3\n102 16 19 -108\n12\n-107 175 135\n-38 -115 42\n140 23 70\n148 -2 39\n-198 -49 89\n172 -151 39\n-179 -52 43\n148 42 150\n176 0 10\n153 68 120\n-56 109 16\n-187 -174 8\n```\n\n### 예제 출력 2\n```\n2\n5\n3\n```\n---\n\n## 풀이\n\n\n### 문제 이해\n\n문제의 길이가 좀 긴데 우리가 필요한 정보만 가져와서 다시 살펴보자.  \n\n>`은하수 지도, 출발점, 도착점`이 주어졌을 때 어린 왕자에게 필요한 `최소의 행성계 진입/이탈 횟수를 구하는 프로그램`을 작성해 보자. 행성계의 경계가 맞닿거나 서로 교차하는 경우는 없다. 또한, 출발점이나 도착점이 행성계 경계에 걸쳐진 경우 역시 입력으로 주어지지 않는다.  \n\n문제에서 요구하는 것은 간단하다. 출발점에서 도착점까지 줄을 긋는데, 원에서 나가거나 들어가는 횟수를 최소한으로 하라는 것이다.     \n\n![](https://raw.githubusercontent.com/HOKAGO-MEMORIES/houkago.posts/main/ps/boj-1004/assets/1.png)\n\n위에서 보여준 예시를 다시 한 번 보자.  출발점에서 도착점까지 이을 수 있는 수 많은 선이 있지만, 위 예시처럼 진입/이탈 횟수가 최소가 되도록 하라는 이야기다.  출발점에서 도착점으로 갈 때 한 번의 이탈과 두 번의 진입이 일어나 예시의 답은 3이다.  \n\n### 문제 해결\n\n행성계를 진입했는지 이탈했는지를 판별하는데에는 많은 방법이 있지만, 내가 생각한 방법은 아래와 같다.  \n\n![](https://raw.githubusercontent.com/HOKAGO-MEMORIES/houkago.posts/main/ps/boj-1004/assets/2.png)\n\n* 1번의 경우, 행성계를 진입/이탈할 필요가 없다.  \n* 2번의 경우, 출발점이 행성계 안에 있는 경우 반드시 최소한 한 번의 이탈이 필요하다.  \n* 3번의 경우, 도착점이 행성계 안에 있는 경우 반드시 최소한 한 번의 진입이 필요하다.  \n\n따라서 진입/이탈 횟수를 알고 싶다면, 2,3번처럼 출발점이나 도착점이 행성계 안에 있음을 확인하면 된다.  \n\n하지만 이대로만 한다면 한가지 문제점이 있다.  \n\n![](https://raw.githubusercontent.com/HOKAGO-MEMORIES/houkago.posts/main/ps/boj-1004/assets/3.png)\n\n출발점과 도착점 두 개가 하나의 행성계에 들어가 있는 경우 위의 방법으로는 진입/이탈 횟수가 한 번 생기게 되지만 이 경우에는 진입/이탈이 필요치 않기 때문에 빼주어야 한다.   \n\n마지막으로 판별은 점과 점사이의 거리를 구해서 판별했다.  \n\n![](https://raw.githubusercontent.com/HOKAGO-MEMORIES/houkago.posts/main/ps/boj-1004/assets/4.png)\n\n추가로 d에 루트를 씌운채로 비교해도 되지만, 양변을 제곱해서 루트를 벗겨낸 뒤에 반지름을 제곱한 것과 비교하여 불필요한 계산 하나를 줄일 수 있다.  \n\n출발점과 도착점 각각 행성계와의 거리를 비교해서 둘 중 하나라도 거리가 반지름보다 작아 행성계 안에 있다면 진입/이탈 횟수를 1 증가시켰다. 이 때, 두 점이 행성계에 모두 들어있는 경우는 생략해야하기 때문에 두 경우 모두 반지름 안에 있는 경우를 뺄 수 있는 XOR 연산자를 사용했다.\n\n---\n\n## 코드\n\n>변수명\n>* t : 테스트 케이스 개수\n>* x_1, y_1 : 출발점\n>* x_2, y_2 : 도착점\n>* n : 행성계 개수\n>* cx, cy : 행성계의 중점\n>* r : 행성계의 반지름\n>* ans : 진입/이탈 횟수\n\n\n``` c++\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint t, x_1, y_1, x_2, y_2, n, cx, cy, r;\n\n\nvoid solve() {\n\n\tcin >> t;\n\n\twhile (t--) {\n\n\t\tint ans = 0;\n\t\tcin >> x_1 >> y_1 >> x_2 >> y_2 >> n;\n\n\t\twhile (n--) {\n\n\t\t\tcin >> cx >> cy >> r;\n\n\t\t\tif (pow((x_1 - cx), 2) + pow((y_1 - cy), 2) < pow(r, 2)\n\t\t\t^ pow((x_2 - cx), 2) + pow((y_2 - cy), 2) < pow(r, 2))\n\t\t\t\tans++;\n\t\t}\n\n\t\tcout << ans << '\\n';\n\t}\n}\n\nint main() {\n    \n    ios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n    \n\tsolve();\n\n    return 0;\n}\n```\n\n---  \n\n![](https://raw.githubusercontent.com/HOKAGO-MEMORIES/houkago.posts/main/ps/boj-1004/assets/5.png)\n \n[1004번: 어린 왕자 (acmicpc.net)](https://www.acmicpc.net/problem/1004)  \n[1004-어린 왕자 · HOKAGO-MEMORIES/BOJ-line123 (github.com)](https://github.com/HOKAGO-MEMORIES/BOJ-line123/tree/72f8f71daad36bb28b015d3f0533624c2bd31682/%EB%B0%B1%EC%A4%80/Silver/1004.%E2%80%85%EC%96%B4%EB%A6%B0%E2%80%85%EC%99%95%EC%9E%90)","permalink":"/boj-1004"},{"title":"[C++] 백준 1181번 : 단어 정렬","date":"2025-01-15","desc":"정렬, 문자열","category":"PS","slug":"boj-1181","thumbnail":null,"body":"## 문제\n\n알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.  \n\n1. 길이가 짧은 것부터  \n2. 길이가 같으면 사전 순으로  \n\n단, 중복된 단어는 하나만 남기고 제거해야 한다.\n\n## 입력\n\n첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000)  \n둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다.  \n주어지는 문자열의 길이는 50을 넘지 않는다.\n\n## 출력\n\n조건에 따라 정렬하여 단어들을 출력한다.\n\n## 예제\n\n### 예제 입력 1\n\n```\n13\nbut\ni\nwont\nhesitate\nno\nmore\nno\nmore\nit\ncannot\nwait\nim\nyours\n```\n\n### 예제 출력 1\n\n```\ni\nim\nit\nno\nbut\nmore\nwait\nwont\nyours\ncannot\nhesitate\n```\n\n---\n\n## 풀이\n\n### 문제 이해\n\n길이가 짧은 것부터 정렬하되, 만약 길이가 같다면 사전 순으로 정렬하면 되는 문제다.  \n사전 순은 알파벳 a ~ z까지 단어를 정렬하는 것을 의미한다.  \n\n문제를 해결하기 전 고려해야할 점이 두가지 있다.  \n> - 중복된 단어는 하나만 남겨야 한다.  \n> - 정렬 기준이 길이 -> 사전 순이다.\n\n### 문제 해결\n\n#### `vector`를 이용한 입력 데이터 저장\n\n입력받은 데이터를 저장하기 위해 `vector`를 사용했다.  \nvector는 동적 배열로 크기가 고정되지 않아서 이렇게 단어의 개수가 N개 입력되는 문제에서 유용하다.  \n안에 요소를 넣으려면 `push_back`을 이용하면 된다.  \n```c++\nvector<string> word;\n\ncin >> str;\nword.push_back(str);\n```\n취향에 따라 다른 것을 이용해도 무방하다.  \n\n---\n\n#### `sort`를 이용한 정렬\n\nsort 알고리즘은 quick sort(퀵 정렬)을 기반으로 하여 평균 시간복잡도는 O(N log N)이다.  \n이 sort를 사용 가능한 방법은 아래와 같다. \n| 코드                                       | 설명                     |\n|-------------------------------------------|--------------------------|\n| **sort(arr, arr+n);**                     | n번째까지                |\n| **sort(v.begin(), v.end());**             | 처음부터 끝까지 (오름차순)  |\n| **sort(v.begin(), v.end(), compare);**    | 사용자 정의 함수 사용    |\n| **sort(v.begin(), v.end(), greater\\<T>());** | 내림차순                |\n| **sort(v.begin(), v.end(), less\\<T>());**   | 오름차순 (default)       |\n\n이중에서 우리가 사용할 것은 3번 째 사용자 정의 함수를 이용하는 것이다.  \n\n```c++\nbool compare(string a, string b) {\n\tif (a.size() == b.size()) {\n\t\treturn a < b;    // 길이가 같다면 사전 순으로 \n\t}\n\treturn a.size() < b.size();    // 길이가 다르다면 길이가 짧은 순으로 \n}\n```\n\n사용자 정의 함수는 두 문자열(여기서는 a와 b)을 비교해서 정렬 순서를 결정한다.  \n리턴 값이 `true`라면 a가 b보다 앞에 위치하게 되고, `false`라면 a가 b보다 뒤에 위치하는 점을 이용하면 된다.  \n즉, 사전 순으로 정렬할 때 앞쪽에 오는 문자열의 부등호 값이 작은 것이다.  \n\n예를 들어 vector에 [\"apple\", \"cherry\", \"banana\"]가 있다고 생각해보자.  \n이 중에 길이가 같은 경우와 다른 경우만 확인해보자.  \n\n> 1. 길이가 같은 경우 (a.size() == b.size())  \n>\n> 길이가 같은 \"cherry\"와 \"banana\"를 각각 a, b로 놓고 비교해보자.  \n> banana가 사전 순으로 정렬하면 앞쪽에 오기 때문에 `a > b`다.  \n> 따라서 return 값은 `false`가 되고, banana - cherry로 정렬된다.  \n>\n\n> 2. 길이가 다른 경우  \n> \n> 길이가 다른 \"apple\"과 \"cherry\"를 각각 a, b로 놓고 비교해보다.  \n> 두 문자열의 size는 각각 5, 6기 때문에 `a.size() < b.size()`다.  \n> 따라서 return 값은 `true`가 되고, apple - cherry로 정렬된다.  \n\n--- \n\n#### `unique`, `erase`를 이용한 중복 제거\n\nunique는 정렬된 vector에서 연속된 중복 요소를 제거하는 함수다.  \n그렇다고 중복되는걸 아예 지워버리는 것은 아니다.  \n중복되지 않는 요소를 앞쪽으로 이동시키고, 중복된 요소들은 뒤쪽에 남긴 뒤 중복된 값이 시작되는 지점의 iterator를 반환한다.  \n```c++\nunique(word.begin(), word.end());\n\n[\"apple\", \"apple\", \"banana\", \"banana\", \"cherry\"]    // 정렬된 vector\n[\"apple\", \"banana\", \"cherry\", \"apple\", \"banana\"]    // unique 호출 후\n// 참고로 unique 호출 후 뒤에 나오는 중복값의 순서는 보장되지 않음\n```\n\n따라서 뒤에 남은 요소도 제거하기 위해 erase 함수를 사용하게 된다.  \nerase는 지정한 범위의 요소를 제거한 후, 제거된 마지막 요소 바로 다음 위치를 가르키는 iterator를 반환한다.  \n```c++\nword.erase(word.begin(), word.end());\n\n[\"apple\", \"banana\", \"cherry\", \"apple\", \"banana\"]    // unique 호출 후\n[\"apple\", \"banana\", \"cherry\"]                       // erase 호출 후\n```\n\n이제 unique 함수의 반환값을 이용하면 이 과정을 한 줄로 정리할 수 있게 된다.  \n```c++\nword.erase(unique(word.begin(), word.end()), word.end());\n```\n\n--- \n\n## 코드\n\n```c++\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool compare(string a, string b) {\n\tif (a.size() == b.size()) {\n\t\treturn a < b;\n\t}\n\treturn a.size() < b.size();\n}\n\nvoid solve() {\n    int N;\n\tcin >> N;\n\n\tvector<string> word;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tword.push_back(str);\n\t}\n\n\tsort(word.begin(), word.end(), compare);\n    \n    word.erase(unique(word.begin(), word.end()), word.end());\n\n\tfor (const string &w : word)\n        cout << w << '\\n';\n}\n\nint main() {\n    \n    ios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n    \n\tsolve();\n\n    return 0;\n}\n```\n\n---\n\n![](https://raw.githubusercontent.com/HOKAGO-MEMORIES/houkago.posts/main/ps/boj-1181/assets/1.png)\n \n[1181번: 단어 정렬 (acmicpc.net)](https://www.acmicpc.net/problem/1181)  \n[1181-단어 정렬 · HOKAGO-MEMORIES/BOJ-line123 (github.com)](https://github.com/HOKAGO-MEMORIES/BOJ-line123/tree/ed51c2c0431442cf8066359c552ad6f06f291b0b/%EB%B0%B1%EC%A4%80/Silver/1181.%E2%80%85%EB%8B%A8%EC%96%B4%E2%80%85%EC%A0%95%EB%A0%AC)","permalink":"/boj-1181"}]